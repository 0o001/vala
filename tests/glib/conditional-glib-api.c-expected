/* glib_conditional_glib_api.c generated by valac, the Vala compiler
 * generated from glib_conditional_glib_api.vala, do not modify */

/* glib 2.54 g_enum_to_string / g_flags_to_string*/
/* glib 2.58 G_GNUC_NO_INLINE*/

#include <glib-object.h>
#include <glib.h>
#include <string.h>
#include <stdlib.h>
#include <gobject/gvaluecollector.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

typedef enum  {
	FOO_ENUM_BAR
} FooEnum;

#define TYPE_FOO_ENUM (foo_enum_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))
typedef enum  {
	FOO_FLAG_BAR = 1 << 0
} FooFlag;

#define TYPE_FOO_FLAG (foo_flag_get_type ())

#define TYPE_FOO_MEM_DUP2 (foo_mem_dup2_get_type ())
typedef struct _FooMemDup2 FooMemDup2;
#define _foo_mem_dup2_free0(var) ((var == NULL) ? NULL : (var = (foo_mem_dup2_free (var), NULL)))
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))

#define TYPE_FOO_VOLATILE (foo_volatile_get_type ())
#define FOO_VOLATILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FOO_VOLATILE, FooVolatile))
#define FOO_VOLATILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FOO_VOLATILE, FooVolatileClass))
#define IS_FOO_VOLATILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FOO_VOLATILE))
#define IS_FOO_VOLATILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FOO_VOLATILE))
#define FOO_VOLATILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FOO_VOLATILE, FooVolatileClass))

typedef struct _FooVolatile FooVolatile;
typedef struct _FooVolatileClass FooVolatileClass;
typedef struct _FooVolatilePrivate FooVolatilePrivate;
enum  {
	FOO_VOLATILE_0_PROPERTY,
	FOO_VOLATILE_NUM_PROPERTIES
};
static GParamSpec* foo_volatile_properties[FOO_VOLATILE_NUM_PROPERTIES];

#define TYPE_BAR_VOLATILE (bar_volatile_get_type ())
#define BAR_VOLATILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BAR_VOLATILE, BarVolatile))
#define BAR_VOLATILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BAR_VOLATILE, BarVolatileClass))
#define IS_BAR_VOLATILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BAR_VOLATILE))
#define IS_BAR_VOLATILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BAR_VOLATILE))
#define BAR_VOLATILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BAR_VOLATILE, BarVolatileClass))

typedef struct _BarVolatile BarVolatile;
typedef struct _BarVolatileClass BarVolatileClass;
typedef struct _BarVolatilePrivate BarVolatilePrivate;
typedef struct _ParamSpecBarVolatile ParamSpecBarVolatile;
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))

struct _FooMemDup2 {
	gint i;
};

struct _FooVolatile {
	GObject parent_instance;
	FooVolatilePrivate * priv;
};

struct _FooVolatileClass {
	GObjectClass parent_class;
};

struct _BarVolatile {
	GTypeInstance parent_instance;
	volatile int ref_count;
	BarVolatilePrivate * priv;
};

struct _BarVolatileClass {
	GTypeClass parent_class;
	void (*finalize) (BarVolatile *self);
};

struct _ParamSpecBarVolatile {
	GParamSpec parent_instance;
};

static gpointer foo_volatile_parent_class = NULL;
static gpointer bar_volatile_parent_class = NULL;

VALA_EXTERN GType foo_enum_get_type (void) G_GNUC_CONST ;
VALA_EXTERN void use_g_enum_to_string (void);
VALA_EXTERN GType foo_flag_get_type (void) G_GNUC_CONST ;
VALA_EXTERN void use_g_flags_to_string (void);
VALA_EXTERN GType foo_mem_dup2_get_type (void) G_GNUC_CONST ;
VALA_EXTERN FooMemDup2* foo_mem_dup2_dup (const FooMemDup2* self);
VALA_EXTERN void foo_mem_dup2_free (FooMemDup2* self);
VALA_EXTERN void use_g_memdup2 (void);
static const gchar** _vala_array_dup1 (const gchar** self,
                                gssize length);
static guint8* _vala_array_dup2 (guint8* self,
                          gssize length);
static GVariant* _variant_new1 (guint8* value,
                         gint value_length1);
static guint8* _variant_get1 (GVariant* value,
                       gint* result_length1);
static GVariant* _variant_new2 (FooMemDup2* value);
static FooMemDup2* _variant_get2 (GVariant* value);
VALA_EXTERN GType foo_volatile_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FooVolatile, g_object_unref)
VALA_EXTERN FooVolatile* foo_volatile_new (void);
VALA_EXTERN FooVolatile* foo_volatile_construct (GType object_type);
static GObject * foo_volatile_constructor (GType type,
                                    guint n_construct_properties,
                                    GObjectConstructParam * construct_properties);
static GType foo_volatile_get_type_once (void);
VALA_EXTERN gpointer bar_volatile_ref (gpointer instance);
VALA_EXTERN void bar_volatile_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_bar_volatile (const gchar* name,
                                     const gchar* nick,
                                     const gchar* blurb,
                                     GType object_type,
                                     GParamFlags flags);
VALA_EXTERN void value_set_bar_volatile (GValue* value,
                             gpointer v_object);
VALA_EXTERN void value_take_bar_volatile (GValue* value,
                              gpointer v_object);
VALA_EXTERN gpointer value_get_bar_volatile (const GValue* value);
VALA_EXTERN GType bar_volatile_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (BarVolatile, bar_volatile_unref)
VALA_EXTERN BarVolatile* bar_volatile_new (void);
VALA_EXTERN BarVolatile* bar_volatile_construct (GType object_type);
static void bar_volatile_finalize (BarVolatile * obj);
static GType bar_volatile_get_type_once (void);
VALA_EXTERN void no_use_volatile (void);
static void _vala_main (void);

static GRegex* _tmp_regex_0 = NULL;

 G_GNUC_NO_INLINE static GType
foo_enum_get_type_once (void)
{
	static const GEnumValue values[] = {{FOO_ENUM_BAR, "FOO_ENUM_BAR", "bar"}, {0, NULL, NULL}};
	GType foo_enum_type_id;
	foo_enum_type_id = g_enum_register_static ("FooEnum", values);
	return foo_enum_type_id;
}

GType
foo_enum_get_type (void)
{
	static gsize foo_enum_type_id__volatile = 0;
	if (g_once_init_enter (&foo_enum_type_id__volatile)) {
		GType foo_enum_type_id;
		foo_enum_type_id = foo_enum_get_type_once ();
		g_once_init_leave (&foo_enum_type_id__volatile, foo_enum_type_id);
	}
	return foo_enum_type_id__volatile;
}

void
use_g_enum_to_string (void)
{
	gchar* _tmp0_;
	_tmp0_ = g_enum_to_string (TYPE_FOO_ENUM, FOO_ENUM_BAR);
	_g_free0 (_tmp0_);
}

 G_GNUC_NO_INLINE static GType
foo_flag_get_type_once (void)
{
	static const GFlagsValue values[] = {{FOO_FLAG_BAR, "FOO_FLAG_BAR", "bar"}, {0, NULL, NULL}};
	GType foo_flag_type_id;
	foo_flag_type_id = g_flags_register_static ("FooFlag", values);
	return foo_flag_type_id;
}

GType
foo_flag_get_type (void)
{
	static gsize foo_flag_type_id__volatile = 0;
	if (g_once_init_enter (&foo_flag_type_id__volatile)) {
		GType foo_flag_type_id;
		foo_flag_type_id = foo_flag_get_type_once ();
		g_once_init_leave (&foo_flag_type_id__volatile, foo_flag_type_id);
	}
	return foo_flag_type_id__volatile;
}

void
use_g_flags_to_string (void)
{
	gchar* _tmp0_;
	_tmp0_ = g_flags_to_string (TYPE_FOO_FLAG, FOO_FLAG_BAR);
	_g_free0 (_tmp0_);
}

FooMemDup2*
foo_mem_dup2_dup (const FooMemDup2* self)
{
	FooMemDup2* dup;
	dup = g_new0 (FooMemDup2, 1);
	memcpy (dup, self, sizeof (FooMemDup2));
	return dup;
}

void
foo_mem_dup2_free (FooMemDup2* self)
{
	g_free (self);
}

 G_GNUC_NO_INLINE static GType
foo_mem_dup2_get_type_once (void)
{
	GType foo_mem_dup2_type_id;
	foo_mem_dup2_type_id = g_boxed_type_register_static ("FooMemDup2", (GBoxedCopyFunc) foo_mem_dup2_dup, (GBoxedFreeFunc) foo_mem_dup2_free);
	return foo_mem_dup2_type_id;
}

GType
foo_mem_dup2_get_type (void)
{
	static gsize foo_mem_dup2_type_id__volatile = 0;
	if (g_once_init_enter (&foo_mem_dup2_type_id__volatile)) {
		GType foo_mem_dup2_type_id;
		foo_mem_dup2_type_id = foo_mem_dup2_get_type_once ();
		g_once_init_leave (&foo_mem_dup2_type_id__volatile, foo_mem_dup2_type_id);
	}
	return foo_mem_dup2_type_id__volatile;
}

static const gchar**
_vala_array_dup1 (const gchar** self,
                  gssize length)
{
	if (length > 0) {
		return g_memdup2 (self, length * sizeof (const gchar*));
	}
	return NULL;
}

static guint8*
string_get_data (const gchar* self,
                 gint* result_length1)
{
	guint8* result;
	guint8* res = NULL;
	gint res_length1;
	gint _res_size_;
	gint _tmp0_;
	gint _tmp1_;
	guint8* _tmp2_;
	gint _tmp2__length1;
	g_return_val_if_fail (self != NULL, NULL);
	res = (guint8*) self;
	res_length1 = -1;
	_res_size_ = res_length1;
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	res_length1 = (gint) _tmp1_;
	_tmp2_ = res;
	_tmp2__length1 = res_length1;
	if (result_length1) {
		*result_length1 = _tmp2__length1;
	}
	result = _tmp2_;
	return result;
}

static guint8*
_vala_array_dup2 (guint8* self,
                  gssize length)
{
	if (length > 0) {
		return g_memdup2 (self, length * sizeof (guint8));
	}
	return NULL;
}

static GVariant*
_variant_new1 (guint8* value,
               gint value_length1)
{
	guint8* _tmp7_;
	_tmp7_ = g_memdup2 (value, value_length1);
	return g_variant_ref_sink (g_variant_new_from_data (G_VARIANT_TYPE ("ay"), _tmp7_, value_length1, TRUE, g_free, _tmp7_));
}

static guint8*
_variant_get1 (GVariant* value,
               gint* result_length1)
{
	gsize _tmp10__length;
	guint8* _tmp10_;
	_tmp10__length = g_variant_get_size (value);
	_tmp10_ = g_memdup2 (g_variant_get_data (value), _tmp10__length);
	*result_length1 = _tmp10__length;
	return _tmp10_;
}

static gpointer
_foo_mem_dup2_dup0 (gpointer self)
{
	return self ? foo_mem_dup2_dup (self) : NULL;
}

static GVariant*
_variant_new2 (FooMemDup2* value)
{
	GVariantBuilder _tmp14_;
	g_variant_builder_init (&_tmp14_, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_tmp14_, g_variant_new_int32 ((*value).i));
	return g_variant_ref_sink (g_variant_builder_end (&_tmp14_));
}

static FooMemDup2*
_variant_get2 (GVariant* value)
{
	FooMemDup2 _tmp17_;
	GVariantIter _tmp18_;
	GVariant* _tmp19_;
	g_variant_iter_init (&_tmp18_, value);
	_tmp19_ = g_variant_iter_next_value (&_tmp18_);
	_tmp17_.i = g_variant_get_int32 (_tmp19_);
	g_variant_unref (_tmp19_);
	return g_memdup2 (&_tmp17_, sizeof (FooMemDup2));
}

void
use_g_memdup2 (void)
{
	const gchar** foo = NULL;
	const gchar** _tmp0_;
	gint foo_length1;
	gint _foo_size_;
	const gchar** bar = NULL;
	const gchar** _tmp1_;
	gint _tmp1__length1;
	gint bar_length1;
	gint _bar_size_;
	guint8* minim = NULL;
	guint8* _tmp2_;
	gint _tmp2__length1;
	gint _tmp3_ = 0;
	guint8* _tmp4_;
	gint _tmp4__length1;
	guint8* _tmp5_;
	gint _tmp5__length1;
	gint minim_length1;
	gint _minim_size_;
	GVariant* minim_v = NULL;
	guint8* _tmp6_;
	gint _tmp6__length1;
	GVariant* _tmp8_;
	guint8* _tmp9_ = NULL;
	gint _tmp9__length1 = 0;
	FooMemDup2* manam = NULL;
	FooMemDup2 _tmp11_ = {0};
	FooMemDup2* _tmp12_;
	GVariant* manam_v = NULL;
	FooMemDup2* _tmp13_;
	GVariant* _tmp15_;
	FooMemDup2* _tmp16_;
	_tmp0_ = g_new0 (const gchar*, 3 + 1);
	_tmp0_[0] = "foo";
	_tmp0_[1] = "bar";
	_tmp0_[2] = "manam";
	foo = _tmp0_;
	foo_length1 = 3;
	_foo_size_ = foo_length1;
	_tmp1_ = (foo != NULL) ? _vala_array_dup1 (foo, foo_length1) : foo;
	_tmp1__length1 = foo_length1;
	bar = _tmp1_;
	bar_length1 = _tmp1__length1;
	_bar_size_ = bar_length1;
	_tmp2_ = string_get_data ("minim", &_tmp3_);
	_tmp2__length1 = _tmp3_;
	_tmp4_ = _tmp2_;
	_tmp4__length1 = _tmp2__length1;
	_tmp5_ = (_tmp4_ != NULL) ? _vala_array_dup2 (_tmp4_, _tmp4__length1) : _tmp4_;
	_tmp5__length1 = _tmp4__length1;
	minim = _tmp5_;
	minim_length1 = _tmp5__length1;
	_minim_size_ = minim_length1;
	_tmp6_ = minim;
	_tmp6__length1 = minim_length1;
	_tmp8_ = _variant_new1 (_tmp6_, _tmp6__length1);
	minim_v = _tmp8_;
	_tmp9_ = _variant_get1 (minim_v, &_tmp9__length1);
	minim = (g_free (minim), NULL);
	minim = _tmp9_;
	minim_length1 = _tmp9__length1;
	_minim_size_ = minim_length1;
	_tmp11_.i = 42;
	_tmp12_ = _foo_mem_dup2_dup0 (&_tmp11_);
	manam = _tmp12_;
	_tmp13_ = manam;
	_tmp15_ = _variant_new2 (_tmp13_);
	manam_v = _tmp15_;
	_tmp16_ = _variant_get2 (manam_v);
	_foo_mem_dup2_free0 (manam);
	manam = _tmp16_;
	_g_variant_unref0 (manam_v);
	_foo_mem_dup2_free0 (manam);
	_g_variant_unref0 (minim_v);
	minim = (g_free (minim), NULL);
	bar = (g_free (bar), NULL);
	foo = (g_free (foo), NULL);
}

FooVolatile*
foo_volatile_construct (GType object_type)
{
	FooVolatile * self = NULL;
	self = (FooVolatile*) g_object_new (object_type, NULL);
	return self;
}

FooVolatile*
foo_volatile_new (void)
{
	return foo_volatile_construct (TYPE_FOO_VOLATILE);
}

static GObject *
foo_volatile_constructor (GType type,
                          guint n_construct_properties,
                          GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	static GObject * FooVolatile_singleton__ref = NULL;
	static GMutex FooVolatile_singleton__lock;
	static gsize FooVolatile_singleton__volatile = 0;
	FooVolatile * self;
	if (g_once_init_enter (&FooVolatile_singleton__volatile)) {
		g_mutex_init (&FooVolatile_singleton__lock);
		g_once_init_leave (&FooVolatile_singleton__volatile, 42);
	}
	g_mutex_lock (&FooVolatile_singleton__lock);
	if (FooVolatile_singleton__ref != NULL) {
		g_object_ref (FooVolatile_singleton__ref);
		g_mutex_unlock (&FooVolatile_singleton__lock);
		return FooVolatile_singleton__ref;
	}
	parent_class = G_OBJECT_CLASS (foo_volatile_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FOO_VOLATILE, FooVolatile);
	FooVolatile_singleton__ref = obj;
	g_object_add_weak_pointer (FooVolatile_singleton__ref, (gpointer) (&FooVolatile_singleton__ref));
	g_mutex_unlock (&FooVolatile_singleton__lock);
	return obj;
}

static void
foo_volatile_class_init (FooVolatileClass * klass,
                         gpointer klass_data)
{
	foo_volatile_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->constructor = foo_volatile_constructor;
}

static void
foo_volatile_instance_init (FooVolatile * self,
                            gpointer klass)
{
}

 G_GNUC_NO_INLINE static GType
foo_volatile_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FooVolatileClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) foo_volatile_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FooVolatile), 0, (GInstanceInitFunc) foo_volatile_instance_init, NULL };
	GType foo_volatile_type_id;
	foo_volatile_type_id = g_type_register_static (G_TYPE_OBJECT, "FooVolatile", &g_define_type_info, 0);
	return foo_volatile_type_id;
}

GType
foo_volatile_get_type (void)
{
	static gsize foo_volatile_type_id__volatile = 0;
	if (g_once_init_enter (&foo_volatile_type_id__volatile)) {
		GType foo_volatile_type_id;
		foo_volatile_type_id = foo_volatile_get_type_once ();
		g_once_init_leave (&foo_volatile_type_id__volatile, foo_volatile_type_id);
	}
	return foo_volatile_type_id__volatile;
}

BarVolatile*
bar_volatile_construct (GType object_type)
{
	BarVolatile* self = NULL;
	self = (BarVolatile*) g_type_create_instance (object_type);
	return self;
}

BarVolatile*
bar_volatile_new (void)
{
	return bar_volatile_construct (TYPE_BAR_VOLATILE);
}

static void
value_bar_volatile_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
value_bar_volatile_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		bar_volatile_unref (value->data[0].v_pointer);
	}
}

static void
value_bar_volatile_copy_value (const GValue* src_value,
                               GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = bar_volatile_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
value_bar_volatile_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
value_bar_volatile_collect_value (GValue* value,
                                  guint n_collect_values,
                                  GTypeCValue* collect_values,
                                  guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		BarVolatile * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = bar_volatile_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
value_bar_volatile_lcopy_value (const GValue* value,
                                guint n_collect_values,
                                GTypeCValue* collect_values,
                                guint collect_flags)
{
	BarVolatile ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = bar_volatile_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
param_spec_bar_volatile (const gchar* name,
                         const gchar* nick,
                         const gchar* blurb,
                         GType object_type,
                         GParamFlags flags)
{
	ParamSpecBarVolatile* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_BAR_VOLATILE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
value_get_bar_volatile (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_BAR_VOLATILE), NULL);
	return value->data[0].v_pointer;
}

void
value_set_bar_volatile (GValue* value,
                        gpointer v_object)
{
	BarVolatile * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_BAR_VOLATILE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_BAR_VOLATILE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		bar_volatile_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		bar_volatile_unref (old);
	}
}

void
value_take_bar_volatile (GValue* value,
                         gpointer v_object)
{
	BarVolatile * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_BAR_VOLATILE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_BAR_VOLATILE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		bar_volatile_unref (old);
	}
}

static void
bar_volatile_class_init (BarVolatileClass * klass,
                         gpointer klass_data)
{
	bar_volatile_parent_class = g_type_class_peek_parent (klass);
	((BarVolatileClass *) klass)->finalize = bar_volatile_finalize;
}

static void
bar_volatile_instance_init (BarVolatile * self,
                            gpointer klass)
{
	self->ref_count = 1;
}

static void
bar_volatile_finalize (BarVolatile * obj)
{
	BarVolatile * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_BAR_VOLATILE, BarVolatile);
	g_signal_handlers_destroy (self);
}

 G_GNUC_NO_INLINE static GType
bar_volatile_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { value_bar_volatile_init, value_bar_volatile_free_value, value_bar_volatile_copy_value, value_bar_volatile_peek_pointer, "p", value_bar_volatile_collect_value, "p", value_bar_volatile_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (BarVolatileClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) bar_volatile_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BarVolatile), 0, (GInstanceInitFunc) bar_volatile_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType bar_volatile_type_id;
	bar_volatile_type_id = g_type_register_fundamental (g_type_fundamental_next (), "BarVolatile", &g_define_type_info, &g_define_type_fundamental_info, 0);
	return bar_volatile_type_id;
}

GType
bar_volatile_get_type (void)
{
	static gsize bar_volatile_type_id__volatile = 0;
	if (g_once_init_enter (&bar_volatile_type_id__volatile)) {
		GType bar_volatile_type_id;
		bar_volatile_type_id = bar_volatile_get_type_once ();
		g_once_init_leave (&bar_volatile_type_id__volatile, bar_volatile_type_id);
	}
	return bar_volatile_type_id__volatile;
}

gpointer
bar_volatile_ref (gpointer instance)
{
	BarVolatile * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
bar_volatile_unref (gpointer instance)
{
	BarVolatile * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		BAR_VOLATILE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

static inline GRegex*
_thread_safe_regex_init (GRegex** re,
                         const gchar * pattern,
                         GRegexCompileFlags compile_flags)
{
	if (g_once_init_enter ((gsize*) re)) {
		GRegex* val = g_regex_new (pattern, compile_flags, 0, NULL);
		g_once_init_leave ((gsize*) re, (gsize) val);
	}
	return *re;
}

static gpointer
_g_regex_ref0 (gpointer self)
{
	return self ? g_regex_ref (self) : NULL;
}

void
no_use_volatile (void)
{
	GRegex* re = NULL;
	GRegex* _tmp0_;
	_tmp0_ = _g_regex_ref0 (_thread_safe_regex_init (&_tmp_regex_0, "mon(str.*o)n", 0 | G_REGEX_CASELESS));
	re = _tmp0_;
	_g_regex_unref0 (re);
}

static void
_vala_main (void)
{
	use_g_enum_to_string ();
	use_g_flags_to_string ();
	use_g_memdup2 ();
	no_use_volatile ();
}

int
main (int argc,
      char ** argv)
{
	_vala_main ();
	return 0;
}

